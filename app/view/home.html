<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title><%=title%></title>
    <!-- three.js、 stats、gui、tween(V8直接运行)-->
    <script type="text/javascript" src="static/js/three.min.js"></script>
    <script type="text/javascript" src="static/js/stats.min.js"></script>
    <script type="text/javascript" src="static/js/dat.gui.min.js"></script>
    <script type="text/javascript" src="static/js/tween.min.js"></script>
    <!-- Geometry、OrbitControls(JavaScript)-->
    <script type="text/javascript" src="static/js/Geometry.js"></script>
    <script type="text/javascript" src="static/js/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
<!--<canvas id="myCanvas"></canvas>-->
</body>
</html>
<script type="module">
  // 区块链
  class BlockChain {
    // 构造函数
    material;
    number = 10;
    size;
    blockChain = [];
    positions = [];
    height = 5;
    time = 1000;

    constructor(material, number = 13, size = 1) {
      this.material = material;
      this.number = number;
      this.size = size;

      let index = 0;
      if (number % 2 === 0) {
        index = 0.5;
      }
      for (index; index < number / 2; index++) {
        if (index === 0) {
          this.positions.push(0);
        } else {
          this.positions.push((-index) * 2);
          this.positions.push(index * 2);
        }
      }
      this.positions = this.bubbleSort(this.positions);
      for (let index = 0; index < number; index++) {
        let block = new Block(this.material, this.size, this.positions[index], this.height, 0);
        block.setPosition(this.positions[index], 0,0);
        this.blockChain[index] = block;
        block.show(scene);
      }
    };

    async animation(){
      console.log('animation');
      let block;
      for (let index = 0; index < this.blockChain.length; index++) {
        if (index === 0){
          block = this.blockChain[0];
        }else {
          this.blockChain[index-1] = this.blockChain[index]
        }
      }

      for (let index = 0; index < this.blockChain.length-1; index++) {
        this.blockChain[index].move(this.blockChain[index].getPositionX(), 0, 0, this.blockChain[index].getPositionX()-2, 0, 0, 10);
      }
      // console.log(this.positions[this.number-1]);
      block.setPosition(this.positions[this.number-1], this.height, 0);
      await block.move(this.positions[this.number-1], this.height, 0, this.positions[this.number-1], 0, 0, this.time);
      this.blockChain[this.number-1] = block;
    };

    async addOneBlock() {
      // 计算生成区块显示位置
      this.positions = [];
      let number = this.blockChain.length + 1;
      let index = 0;
      if (number % 2 === 0) {
        index = 0.5;
      }
      for (index; index < number / 2; index++) {
        if (index === 0) {
          this.positions.push(0);
        } else {
          this.positions.push((-index) * 2);
          this.positions.push(index * 2);
        }
      }
      this.positions = this.bubbleSort(this.positions);
      // 创建区块
      let block = new Block(this.material, this.size, this.positions[index], this.height, 0);
      for (index = 0; index < this.blockChain.length; index++) {
        this.blockChain[index].move(this.blockChain[index].getPositionX(), 0, 0, this.positions[index], 0, 0, 10);
      }
      // 从上方掉下来
      block.show(scene);
      await block.move(this.positions[index], this.height, 0, this.positions[index], 0, 0, this.time);
      this.blockChain[this.blockChain.length] = block;
    };

    bubbleSort(arr) {
      const list = arr.slice(); //保证函数为纯函数
      const len = list.length;
      for (let i = 0; i < len; i++) {
        for (let j = len - 1; j > i; j--) {
          if (list[j] < list[j - 1]) {
            [ list[j - 1], list[j] ] = [ list[j], list[j - 1] ];
          }
        }
      }
      return list;
    };
  }
  // 区块
  class Block {
    // 构造方法
    material;
    geometry;
    mesh;

    constructor(material, size = 1) {
      // 材料
      this.material = material;
      // 几何图形
      this.geometry = new THREE.BoxGeometry(size, size, size);
      // 网格模型
      this.mesh = new THREE.Mesh(this.geometry, this.material);
    };

    setPosition(x, y, z) {
      this.mesh.position.set(x, y, z);
    }

    getPositionX() {
      return this.mesh.position.x;
    }

    // 展示
    show(scene) {
      scene.add(this.mesh);
    }

    // 掉下
    move(x, y, z, x_, y_, z_, time = 100) {
      return new Promise((async (resolve) => {
        let mesh = this.mesh;
        let onUpdate = function() {
          if (this.x === x_ && this.y === y_ && this.z === z_) {
            mesh = undefined;
            resolve(1);
          } else {
            mesh.position.set(this.x, this.y, this.z);
            // console.log(this.x, this.y, this.z);
          }
        };
        new TWEEN.Tween({ x: x, y: y, z: z })
          .to({ x: x_, y: y_, z: z_ }, 500)
          .easing(TWEEN.Easing.Bounce.Out)
          .onUpdate(onUpdate)
          .start();
      }));
    }
  }

  // 3D必备参数：场景、点光源、环境光源、摄像机、渲染器、控制器
  let scene, point, light, camera, renderer, controls;
  // 背景相关参数：网格、x轴、y轴、z轴
  let grid, coordinateX, coordinateY,coordinateZ;
  // 调试相关：GUI、监控状态
  let gui, stats;
  // 区块链相关参数
  let material, blockChain;

  // 区块贴图
  material = new THREE.MeshPhongMaterial({
    map: THREE.ImageUtils.loadTexture('static/images/block.png'),
    needsUpdate: true,
    transparent: true,
  });

  // 1. 场景
  scene = new THREE.Scene();
  // 2.1 点光源
  point = new THREE.PointLight(0xffffff);
  point.position.set(20, 30, 50);
  scene.add(point);
  // 2.2 环境光
  light = new THREE.AmbientLight(0x404040, 1);
  scene.add(light);
  // 2. 摄像机(透视相机)
  camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 2, 8);
  camera.lookAt(0, 0, 0);
  // 3. 渲染器
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight * 0.95);
  document.body.appendChild(renderer.domElement);
  // 4. 控制器
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.addEventListener('change', render);
  let controlsEnd = () => {
    console.log('controlsEnd:', camera.position);
  };
  controls.addEventListener('end', controlsEnd);
  // 5.1 背景网格
  grid = new THREE.GridHelper(20, 20, 0x000000, 0x000000);
  grid.material.opacity = 0.2;
  grid.material.transparent = true;
  scene.add(grid);
  // 5.2 直角坐标系
  coordinateX = new THREE.Line(new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0, 0, 0), new THREE.Vector3(2, 0, 0) ]), new THREE.LineBasicMaterial({ color: 0xff0000 }));  // 根据材料创建线条
  coordinateY = new THREE.Line(new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 2, 0) ]), new THREE.LineBasicMaterial({ color: 0x00ff00 }));  // 根据材料创建线条
  coordinateZ = new THREE.Line(new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 2) ]), new THREE.LineBasicMaterial({ color: 0x0000ff }));  // 根据材料创建线条
  scene.add(coordinateX);  // 将线条添加到场景内
  scene.add(coordinateY);  // 将线条添加到场景内
  scene.add(coordinateZ);  // 将线条添加到场景内
  // 5.3 区块链(立方体)
  blockChain = new BlockChain(material, 13);
  // 6.1 GUI
  gui = new dat.GUI();
  let folderLocal = gui.addFolder('按钮');
  let params = {
    addOneBlock: function() {
      blockChain.addOneBlock();
    },
    animation: function() {
      blockChain.animation();
    }
  };
  folderLocal.add(params, 'addOneBlock');
  folderLocal.add(params, 'animation');
  folderLocal.open();
  // 6.2 Stats
  stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.right = '8px';
  stats.domElement.style.top = '8px';
  document.body.appendChild(stats.domElement);
  // 7. 定时器更新动画
  window.setInterval(animation, 1000);
  async function animation() {
    await blockChain.animation();
  }
  // 8. 定时渲染
  function render() {
    requestAnimationFrame(render);
    TWEEN.update();
    renderer.render(scene, camera);
  }
  render();
</script>


